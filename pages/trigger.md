---
layout: page
title: Триггер
---
# {{ page.title }}

Триггер, институтская *любовь* всех студентов...

Триггер, это элементарное запоминающее устройство. Если вы заметили, то выходы всех предыдущих логических элементом строго зависели от их входов.
Зная, где на каких входах есть питание мы могли точно сказать, не смотря глазами, будет ли питание на выходе. Эти элементы "не имели памяти".

Триггер же память имеет. Это значит, что если закрыть выход и показать вам только вход - вы не скажете точно что на выходе (точнее - не всегда не скажете, но об этом как раз дальше). И это очень хорошо! Ведь мы строим компьютер, а не логарифмическую линейку.

Итак, Триггер (в рассматриваемом случае - RS-триггер, по именам входов) - элементарное запоминающее устройство, которое сохраняет состояние своего выхода, когда на входах у него нули (на входы не подано питание). Сначала мы соберем его из логических элементов, а потом оптимизируем по площади, чтобы занимал как можно меньше места.

В общем, триггер переключает выходной сигнал по выбору одного из входных. Если выбрать S̅ (от set) - выход (Q) переключится в 1. Если выбрать R̅ (reset) - в 0.
Вариант с одновременным включением обоих входных является запрещенным. Почему запрещенным - попробуйте сами (поставьте на паузу, включите оба входа, снимите с паузы; ttl в этой главе обычный, 5 тактов). Кто не попробовал - потому, что триггер начинает колбасить и он переключается попеременно то туда то сюда

Для удобства второй выход (инверсный к первому), тоже выведен. И назван Q̅.

```layout
:o white
:O white
:i cyan :* cyan
:y orange
+-------------------------------------+
|                                     |
| oooo                          oo    |
|                              o  o   |
|  ooo                         o  o   |
| o      OO    OO              o oo   |
|  oo  iiO ooooO oo             oo o  |
|    o   OO    OO OO  OO              |
| ooo             O ooO ooooooooyyy   |
|              OO OO  OO   o          |
|            ooO oo        o          |
|            o OO          o          |
|            o             o   oooo   |
|            ooooooooooooo o          |
|                        o o    oo    |
|            oooooooooooo oo   o  o   |
|            o           o     o  o   |
|            o OO        o     o oo   |
| oooo       ooO oo      o      oo o  |
|              OO OO  OO o            |
| ooo             O ooO ooooooooo     |
| o  o   OO    OO OO  OO              |
| ooo  *iO ooooO oo                   |
| o o    OO    OO                     |
| o  o                                |
|                                     |
+-------------------------------------+
```
{:animated="auto"}

Это был обычный, не оптимизированный по площади триггер, который реагировал сразу же, как на вход подать сигнал. А что, если мы хотим управлять не только установкой значения триггера, но и моментом времени, когда устанавливать? Зачем? Потому, что в будущем мы захотим синхронизировать разные блоки нашего процессора (об этом еще будет).

Плюс, можно заметить, что полезные (устанавливающие) сигналы входов всегда отличаются. Если мы хотим установить 1, мы включаем S и выключаем R. А если в 0 - наоборот. Так почему бы не завести один вход, который будет передавать прямой сигнал на R, и инвертированный на S? При этом добавив другой вход (назовем его sync), который позволит нашему задающему значение сигналу проходить только тогда, когда он включен.

Вот, эта схема. Компактная и красивая. Голубой - задающий сигнал (1 - значит запомнить "1", 0 - значит запомнить "0"). Желтый - разрешающий запись (наш sync). А зеленый - выход триггера, его "запомненное" состояние.

На схеме триггер с "0". Чтобы выставить его в "1" надо нажать паузу, выставить голубую и желтые линии в активное состояние, снять паузу. Чтобы сбросить - достаточно снова включить желтую линию.
```layout
:x white
:o yellow :* yellow
:c cyan
:g green
+--------------------+
|          *         |
| c        o         |
| cc xx xx o    gggg |
| c xx xx x xxx gggg |
| cc xx xx o x ggggg |
| c     x  o xx gggg |
| c    o ooo x  gggg |
| c    ooo   x ggggg |
| c    o o   xx gggg |
| cc    x  xx  ggggg |
| c xxxxxxxx ggggggg |
| cc       xx gggggg |
|                 g  |
+--------------------+
```
{:animated="auto"}

Прошу внимательнее посмотреть на схему. Видно, что неактивный желтый sync блокирует сигналы входа (белые сигналы к зеленому выходу), а вот выключенный - наоборот, пропускает. При этом включенный голубой вход выключает нижний белый, который в свою очередь включает выход. А выключенный голубой вход - наоборот, включает инвертированный верхний белый и на выход не подается вообще никакого сигнала, выключая его. Не забываем, что проводник переходит в активное состояние (в "1", под "напряжение") если на него хоть где-то это напряжение подать. Если не подавать нигде, то он и не включится сам.

Вот, чтобы удобнее было рассмотреть я размещу хорошо замедленную копию (до 1 такта в секунду).
```layout
:x white
:o yellow :* yellow
:c cyan
:g green
+--------------------+
|          *         |
| c        o         |
| cc xx xx o    gggg |
| c xx xx x xxx gggg |
| cc xx xx o x ggggg |
| c     x  o xx gggg |
| c    o ooo x  gggg |
| c    ooo   x ggggg |
| c    o o   xx gggg |
| cc    x  xx  ggggg |
| c xxxxxxxx ggggggg |
| cc       xx gggggg |
|                 g  |
+--------------------+
```
{:animated="auto" fps="1"}

Выход у нас такой большой только для красоты - чтобы его было хорошо видно на большой схеме. Ведь это же самый настоящий бит! А из битов собираются байты, из байтов - память, а память... Но про память тоже дальше, в соответствующем разделе.

А сейчас, наигравшись с битами, перейдем к еще одному элементарному блоку нашей схемы - [тактовому генератору...](clock-generator.html).